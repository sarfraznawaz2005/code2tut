const { Node } = require('pocketflow');
const path = require('path');
const chalk = require('chalk');
const { writeMarkdownFiles } = require('../formats/markdown');
const { generateHtmlContent, writeHtmlFiles } = require('../formats/html');
const { writePdfFiles } = require('../formats/pdf');

class CombineTutorialNode extends Node {
  constructor(maxRetries = 3, wait = 20) {
    super();
    this.maxRetries = maxRetries;
    this.wait = wait;
    this.hasLogged = false; // Flag to ensure message is printed only once
    this.retryCount = 0; // Track retries
  }

  async prep(shared) {
    const projectName = shared.projectName;
    const outputBaseDir = shared.get ? shared.get("output_dir") : (shared.outputDir || 'output'); // Handle both dict and object access
    const outputPath = path.join(outputBaseDir, projectName);
    const outputFormat = shared.outputFormat || 'html'; // Get the format option
    const repoUrl = shared.repoUrl || shared.repo_url; // Handle both formats

    // Get potentially translated data
    if (!shared.relationships || !shared.chapterOrder || !shared.abstractions || !shared.chapters) {
      throw new Error('Missing required shared data: relationships, chapterOrder, abstractions, or chapters');
    }
    const relationshipsData = shared.relationships; // {"summary": str, "details": [{"from": int, "to": int, "label": str}]} -> summary/label potentially translated
    const chapterOrder = shared.chapterOrder; // indices
    const abstractions = shared.abstractions; // list of dicts -> name/description potentially translated
    const chaptersContent = shared.chapters; // list of strings -> content potentially translated

    // --- Generate Mermaid Diagram ---
    const mermaidLines = ['flowchart TD'];
    // Add nodes for each abstraction using potentially translated names
    for (let i = 0; i < abstractions.length; i++) {
      const nodeId = `A${i}`;
      // Use potentially translated name, sanitize for Mermaid ID and label
      const sanitizedName = abstractions[i].name.replace(/"/g, '');
      const nodeLabel = sanitizedName; // Using sanitized name only
      mermaidLines.push(`${nodeId}["${nodeLabel}"]`); // Node label uses potentially translated name
    }
    // Add edges for relationships using potentially translated labels
    for (const rel of relationshipsData.details) {
      const fromNodeId = `A${rel.from}`;
      const toNodeId = `A${rel.to}`;
      // Use potentially translated label, sanitize
      let edgeLabel = rel.label.replace(/"/g, '').replace(/\n/g, ' '); // Basic sanitization
      const maxLabelLen = 30;
      if (edgeLabel.length > maxLabelLen) {
        edgeLabel = edgeLabel.substring(0, maxLabelLen - 3) + '...';
      }
      mermaidLines.push(`${fromNodeId} -- "${edgeLabel}" --> ${toNodeId}`); // Edge label uses potentially translated label
    }

    const mermaidDiagram = mermaidLines.join('\n');
    // --- End Mermaid ---

    // --- Prepare index.md content ---
    let indexContent = `# Tutorial: ${projectName}\n\n`;
    indexContent += `${relationshipsData.summary}\n\n`; // Use the potentially translated summary directly
    // Keep fixed strings in English
    if (repoUrl) {
      indexContent += `**Source Repository:** [${repoUrl}](${repoUrl})\n\n`;
    }

    // Add Mermaid diagram for relationships (diagram itself uses potentially translated names/labels)
    indexContent += "```mermaid\n";
    indexContent += mermaidDiagram + "\n";
    indexContent += "```\n\n";

    // Keep fixed strings in English
    indexContent += "## Chapters\n\n";

    const chapterFiles = [];
    // Generate chapter links based on the determined order, using potentially translated names
    for (let i = 0; i < chapterOrder.length; i++) {
      const abstractionIndex = chapterOrder[i];
      // Ensure index is valid and we have content for it
      if (0 <= abstractionIndex && abstractionIndex < abstractions.length && i < chaptersContent.length) {
        const abstractionName = abstractions[abstractionIndex].name; // Potentially translated name
        // Sanitize potentially translated name for filename
        const safeName = abstractionName.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
        const filename = `${String(i + 1).padStart(2, '0')}_${safeName}.md`;
        indexContent += `${i + 1}. [${abstractionName}](${filename})\n`; // Use potentially translated name in link text

        // Add attribution to chapter content (using English fixed string)
        let chapterContent = chaptersContent[i]; // Potentially translated content
        if (!chapterContent.endsWith('\n\n')) {
          chapterContent += '\n\n';
        }
        // Keep fixed strings in English
        chapterContent += `---\n\nGenerated by [Code2Tutorial](https://github.com/sarfraznawaz2005/code2tut)`;

        // Store filename and corresponding content
        chapterFiles.push({ filename, content: chapterContent });
      } else {
        console.log(`Warning: Mismatch between chapter order, abstractions, or content at index ${i} (abstraction index ${abstractionIndex}). Skipping file generation for this entry.`);
      }
    }

    // Add attribution to index content (using English fixed string)
    indexContent += `\n\n---\n\nGenerated by [Code2Tutorial](https://github.com/sarfraznawaz2005/code2tut)`;

    // Generate HTML content using the html handler (needed for HTML and PDF)
    if (!indexContent || !chapterFiles) {
      throw new Error('Invalid input: indexContent or chapterFiles is undefined');
    }
    const { indexHtmlContent, chapterHtmlFiles } = await generateHtmlContent(indexContent, chapterFiles, projectName);

    return {
      outputPath,
      indexContent,
      chapterFiles, // Markdown files
      indexHtmlContent,
      chapterHtmlFiles, // HTML files
      outputFormat, // Pass the format to exec
      projectName, // Pass projectName to exec
    };
  }

  async exec(prepRes) {
    this.retryCount++;
    const outputPath = prepRes.outputPath;
    const indexContent = prepRes.indexContent;
    const chapterFiles = prepRes.chapterFiles;
    const indexHtmlContent = prepRes.indexHtmlContent;
    const chapterHtmlFiles = prepRes.chapterHtmlFiles;
    const outputFormat = prepRes.outputFormat;
    const projectName = prepRes.projectName;

    if (!this.hasLogged) {
      console.log(chalk.yellow(`\nðŸ“š Combining tutorial into directory: ${outputPath} (format: ${outputFormat})`));
      this.hasLogged = true;
    }

    if (this.retryCount > 1) {
      console.log(chalk.blue(`  - Retry ${this.retryCount - 1} for CombineTutorialNode`));
    }

    // Conditionally write files based on the format
    if (outputFormat === 'markdown') {
      await writeMarkdownFiles(outputPath, indexContent, chapterFiles);
    } else if (outputFormat === 'html') {
      await writeHtmlFiles(outputPath, indexHtmlContent, chapterHtmlFiles);
    } else if (outputFormat === 'pdf') {
      await writePdfFiles(outputPath, indexHtmlContent, chapterHtmlFiles, projectName);
    } else {
      console.log(chalk.red(`Unknown format: ${outputFormat}. Defaulting to HTML.`));
      await writeHtmlFiles(outputPath, indexHtmlContent, chapterHtmlFiles);
    }

    return outputPath; // Return the final path
  }

  async post(shared, prepRes, execRes) {
    shared.finalOutputDir = execRes; // Store the output path
    console.log(`\nâœ… Tutorial generation complete! Files are in: ` + chalk.green(`${execRes}`));
  }
}

module.exports = { CombineTutorialNode };